/*
 * Snippets API
 * Test description
 *
 * OpenAPI spec version: v1
 * Contact: contact@snippets.local
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.limix.awx.api.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.limix.awx.api.model.LaunchedBy;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import org.threeten.bp.OffsetDateTime;
/**
 * AdHocCommandList
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-05-25T17:26:39.970+08:00[Asia/Shanghai]")
public class AdHocCommandList {
  @SerializedName("id")
  private Integer id = null;

  @SerializedName("type")
  private String type = null;

  @SerializedName("url")
  private String url = null;

  @SerializedName("related")
  private Object related = null;

  @SerializedName("summary_fields")
  private Object summaryFields = null;

  @SerializedName("created")
  private String created = null;

  @SerializedName("modified")
  private String modified = null;

  @SerializedName("name")
  private String name = null;

  /**
   * Gets or Sets launchType
   */
  @JsonAdapter(LaunchTypeEnum.Adapter.class)
  public enum LaunchTypeEnum {
    MANUAL("manual"),
    RELAUNCH("relaunch"),
    CALLBACK("callback"),
    SCHEDULED("scheduled"),
    DEPENDENCY("dependency"),
    WORKFLOW("workflow"),
    WEBHOOK("webhook"),
    SYNC("sync"),
    SCM("scm");

    private String value;

    LaunchTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LaunchTypeEnum fromValue(String input) {
      for (LaunchTypeEnum b : LaunchTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LaunchTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LaunchTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public LaunchTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LaunchTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("launch_type")
  private LaunchTypeEnum launchType = null;

  /**
   * Gets or Sets status
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    NEW("new"),
    PENDING("pending"),
    WAITING("waiting"),
    RUNNING("running"),
    SUCCESSFUL("successful"),
    FAILED("failed"),
    ERROR("error"),
    CANCELED("canceled");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String input) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StatusEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("status")
  private StatusEnum status = null;

  @SerializedName("execution_environment")
  private Integer executionEnvironment = null;

  @SerializedName("failed")
  private Boolean failed = null;

  @SerializedName("started")
  private OffsetDateTime started = null;

  @SerializedName("finished")
  private OffsetDateTime finished = null;

  @SerializedName("canceled_on")
  private OffsetDateTime canceledOn = null;

  @SerializedName("elapsed")
  private String elapsed = null;

  @SerializedName("job_explanation")
  private String jobExplanation = null;

  @SerializedName("execution_node")
  private String executionNode = null;

  @SerializedName("controller_node")
  private String controllerNode = null;

  @SerializedName("launched_by")
  private LaunchedBy launchedBy = null;

  @SerializedName("work_unit_id")
  private String workUnitId = null;

  /**
   * Gets or Sets jobType
   */
  @JsonAdapter(JobTypeEnum.Adapter.class)
  public enum JobTypeEnum {
    RUN("run"),
    CHECK("check");

    private String value;

    JobTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static JobTypeEnum fromValue(String input) {
      for (JobTypeEnum b : JobTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<JobTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JobTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public JobTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return JobTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("job_type")
  private JobTypeEnum jobType = JobTypeEnum.RUN;

  @SerializedName("inventory")
  private Integer inventory = null;

  @SerializedName("limit")
  private String limit = "";

  @SerializedName("credential")
  private Integer credential = null;

  /**
   * Gets or Sets moduleName
   */
  @JsonAdapter(ModuleNameEnum.Adapter.class)
  public enum ModuleNameEnum {
    COMMAND("command"),
    SHELL("shell"),
    YUM("yum"),
    APT("apt"),
    APT_KEY("apt_key"),
    APT_REPOSITORY("apt_repository"),
    APT_RPM("apt_rpm"),
    SERVICE("service"),
    GROUP("group"),
    USER("user"),
    MOUNT("mount"),
    PING("ping"),
    SELINUX("selinux"),
    SETUP("setup"),
    WIN_PING("win_ping"),
    WIN_SERVICE("win_service"),
    WIN_UPDATES("win_updates"),
    WIN_GROUP("win_group"),
    WIN_USER("win_user");

    private String value;

    ModuleNameEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ModuleNameEnum fromValue(String input) {
      for (ModuleNameEnum b : ModuleNameEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ModuleNameEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModuleNameEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public ModuleNameEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ModuleNameEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("module_name")
  private ModuleNameEnum moduleName = ModuleNameEnum.COMMAND;

  @SerializedName("module_args")
  private String moduleArgs = "";

  @SerializedName("forks")
  private Integer forks = null;

  @SerializedName("verbosity")
  private Integer verbosity = null;

  @SerializedName("extra_vars")
  private String extraVars = "";

  @SerializedName("become_enabled")
  private Boolean becomeEnabled = false;

  @SerializedName("diff_mode")
  private Boolean diffMode = false;

   /**
   * Get id
   * @return id
  **/
  @Schema(description = "")
  public Integer getId() {
    return id;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public String getType() {
    return type;
  }

   /**
   * Get url
   * @return url
  **/
  @Schema(description = "")
  public String getUrl() {
    return url;
  }

  public AdHocCommandList related(Object related) {
    this.related = related;
    return this;
  }

   /**
   * Get related
   * @return related
  **/
  @Schema(description = "")
  public Object getRelated() {
    return related;
  }

  public void setRelated(Object related) {
    this.related = related;
  }

  public AdHocCommandList summaryFields(Object summaryFields) {
    this.summaryFields = summaryFields;
    return this;
  }

   /**
   * Get summaryFields
   * @return summaryFields
  **/
  @Schema(description = "")
  public Object getSummaryFields() {
    return summaryFields;
  }

  public void setSummaryFields(Object summaryFields) {
    this.summaryFields = summaryFields;
  }

   /**
   * Get created
   * @return created
  **/
  @Schema(description = "")
  public String getCreated() {
    return created;
  }

   /**
   * Get modified
   * @return modified
  **/
  @Schema(description = "")
  public String getModified() {
    return modified;
  }

   /**
   * Get name
   * @return name
  **/
  @Schema(description = "")
  public String getName() {
    return name;
  }

   /**
   * Get launchType
   * @return launchType
  **/
  @Schema(description = "")
  public LaunchTypeEnum getLaunchType() {
    return launchType;
  }

   /**
   * Get status
   * @return status
  **/
  @Schema(description = "")
  public StatusEnum getStatus() {
    return status;
  }

  public AdHocCommandList executionEnvironment(Integer executionEnvironment) {
    this.executionEnvironment = executionEnvironment;
    return this;
  }

   /**
   * The container image to be used for execution.
   * @return executionEnvironment
  **/
  @Schema(description = "The container image to be used for execution.")
  public Integer getExecutionEnvironment() {
    return executionEnvironment;
  }

  public void setExecutionEnvironment(Integer executionEnvironment) {
    this.executionEnvironment = executionEnvironment;
  }

   /**
   * Get failed
   * @return failed
  **/
  @Schema(description = "")
  public Boolean isFailed() {
    return failed;
  }

   /**
   * The date and time the job was queued for starting.
   * @return started
  **/
  @Schema(description = "The date and time the job was queued for starting.")
  public OffsetDateTime getStarted() {
    return started;
  }

   /**
   * The date and time the job finished execution.
   * @return finished
  **/
  @Schema(description = "The date and time the job finished execution.")
  public OffsetDateTime getFinished() {
    return finished;
  }

   /**
   * The date and time when the cancel request was sent.
   * @return canceledOn
  **/
  @Schema(description = "The date and time when the cancel request was sent.")
  public OffsetDateTime getCanceledOn() {
    return canceledOn;
  }

   /**
   * Elapsed time in seconds that the job ran.
   * @return elapsed
  **/
  @Schema(description = "Elapsed time in seconds that the job ran.")
  public String getElapsed() {
    return elapsed;
  }

   /**
   * A status field to indicate the state of the job if it wasn&#x27;t able to run and capture stdout
   * @return jobExplanation
  **/
  @Schema(description = "A status field to indicate the state of the job if it wasn't able to run and capture stdout")
  public String getJobExplanation() {
    return jobExplanation;
  }

   /**
   * The node the job executed on.
   * @return executionNode
  **/
  @Schema(description = "The node the job executed on.")
  public String getExecutionNode() {
    return executionNode;
  }

   /**
   * The instance that managed the execution environment.
   * @return controllerNode
  **/
  @Schema(description = "The instance that managed the execution environment.")
  public String getControllerNode() {
    return controllerNode;
  }

  public AdHocCommandList launchedBy(LaunchedBy launchedBy) {
    this.launchedBy = launchedBy;
    return this;
  }

   /**
   * Get launchedBy
   * @return launchedBy
  **/
  @Schema(description = "")
  public LaunchedBy getLaunchedBy() {
    return launchedBy;
  }

  public void setLaunchedBy(LaunchedBy launchedBy) {
    this.launchedBy = launchedBy;
  }

   /**
   * The Receptor work unit ID associated with this job.
   * @return workUnitId
  **/
  @Schema(description = "The Receptor work unit ID associated with this job.")
  public String getWorkUnitId() {
    return workUnitId;
  }

  public AdHocCommandList jobType(JobTypeEnum jobType) {
    this.jobType = jobType;
    return this;
  }

   /**
   * Get jobType
   * @return jobType
  **/
  @Schema(description = "")
  public JobTypeEnum getJobType() {
    return jobType;
  }

  public void setJobType(JobTypeEnum jobType) {
    this.jobType = jobType;
  }

  public AdHocCommandList inventory(Integer inventory) {
    this.inventory = inventory;
    return this;
  }

   /**
   * Get inventory
   * @return inventory
  **/
  @Schema(description = "")
  public Integer getInventory() {
    return inventory;
  }

  public void setInventory(Integer inventory) {
    this.inventory = inventory;
  }

  public AdHocCommandList limit(String limit) {
    this.limit = limit;
    return this;
  }

   /**
   * Get limit
   * @return limit
  **/
  @Schema(description = "")
  public String getLimit() {
    return limit;
  }

  public void setLimit(String limit) {
    this.limit = limit;
  }

  public AdHocCommandList credential(Integer credential) {
    this.credential = credential;
    return this;
  }

   /**
   * Get credential
   * @return credential
  **/
  @Schema(description = "")
  public Integer getCredential() {
    return credential;
  }

  public void setCredential(Integer credential) {
    this.credential = credential;
  }

  public AdHocCommandList moduleName(ModuleNameEnum moduleName) {
    this.moduleName = moduleName;
    return this;
  }

   /**
   * Get moduleName
   * @return moduleName
  **/
  @Schema(description = "")
  public ModuleNameEnum getModuleName() {
    return moduleName;
  }

  public void setModuleName(ModuleNameEnum moduleName) {
    this.moduleName = moduleName;
  }

  public AdHocCommandList moduleArgs(String moduleArgs) {
    this.moduleArgs = moduleArgs;
    return this;
  }

   /**
   * Get moduleArgs
   * @return moduleArgs
  **/
  @Schema(description = "")
  public String getModuleArgs() {
    return moduleArgs;
  }

  public void setModuleArgs(String moduleArgs) {
    this.moduleArgs = moduleArgs;
  }

  public AdHocCommandList forks(Integer forks) {
    this.forks = forks;
    return this;
  }

   /**
   * Get forks
   * minimum: 0
   * maximum: 2147483647
   * @return forks
  **/
  @Schema(description = "")
  public Integer getForks() {
    return forks;
  }

  public void setForks(Integer forks) {
    this.forks = forks;
  }

  public AdHocCommandList verbosity(Integer verbosity) {
    this.verbosity = verbosity;
    return this;
  }

   /**
   * Get verbosity
   * @return verbosity
  **/
  @Schema(description = "")
  public Integer getVerbosity() {
    return verbosity;
  }

  public void setVerbosity(Integer verbosity) {
    this.verbosity = verbosity;
  }

  public AdHocCommandList extraVars(String extraVars) {
    this.extraVars = extraVars;
    return this;
  }

   /**
   * Get extraVars
   * @return extraVars
  **/
  @Schema(description = "")
  public String getExtraVars() {
    return extraVars;
  }

  public void setExtraVars(String extraVars) {
    this.extraVars = extraVars;
  }

  public AdHocCommandList becomeEnabled(Boolean becomeEnabled) {
    this.becomeEnabled = becomeEnabled;
    return this;
  }

   /**
   * Get becomeEnabled
   * @return becomeEnabled
  **/
  @Schema(description = "")
  public Boolean isBecomeEnabled() {
    return becomeEnabled;
  }

  public void setBecomeEnabled(Boolean becomeEnabled) {
    this.becomeEnabled = becomeEnabled;
  }

  public AdHocCommandList diffMode(Boolean diffMode) {
    this.diffMode = diffMode;
    return this;
  }

   /**
   * Get diffMode
   * @return diffMode
  **/
  @Schema(description = "")
  public Boolean isDiffMode() {
    return diffMode;
  }

  public void setDiffMode(Boolean diffMode) {
    this.diffMode = diffMode;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AdHocCommandList adHocCommandList = (AdHocCommandList) o;
    return Objects.equals(this.id, adHocCommandList.id) &&
        Objects.equals(this.type, adHocCommandList.type) &&
        Objects.equals(this.url, adHocCommandList.url) &&
        Objects.equals(this.related, adHocCommandList.related) &&
        Objects.equals(this.summaryFields, adHocCommandList.summaryFields) &&
        Objects.equals(this.created, adHocCommandList.created) &&
        Objects.equals(this.modified, adHocCommandList.modified) &&
        Objects.equals(this.name, adHocCommandList.name) &&
        Objects.equals(this.launchType, adHocCommandList.launchType) &&
        Objects.equals(this.status, adHocCommandList.status) &&
        Objects.equals(this.executionEnvironment, adHocCommandList.executionEnvironment) &&
        Objects.equals(this.failed, adHocCommandList.failed) &&
        Objects.equals(this.started, adHocCommandList.started) &&
        Objects.equals(this.finished, adHocCommandList.finished) &&
        Objects.equals(this.canceledOn, adHocCommandList.canceledOn) &&
        Objects.equals(this.elapsed, adHocCommandList.elapsed) &&
        Objects.equals(this.jobExplanation, adHocCommandList.jobExplanation) &&
        Objects.equals(this.executionNode, adHocCommandList.executionNode) &&
        Objects.equals(this.controllerNode, adHocCommandList.controllerNode) &&
        Objects.equals(this.launchedBy, adHocCommandList.launchedBy) &&
        Objects.equals(this.workUnitId, adHocCommandList.workUnitId) &&
        Objects.equals(this.jobType, adHocCommandList.jobType) &&
        Objects.equals(this.inventory, adHocCommandList.inventory) &&
        Objects.equals(this.limit, adHocCommandList.limit) &&
        Objects.equals(this.credential, adHocCommandList.credential) &&
        Objects.equals(this.moduleName, adHocCommandList.moduleName) &&
        Objects.equals(this.moduleArgs, adHocCommandList.moduleArgs) &&
        Objects.equals(this.forks, adHocCommandList.forks) &&
        Objects.equals(this.verbosity, adHocCommandList.verbosity) &&
        Objects.equals(this.extraVars, adHocCommandList.extraVars) &&
        Objects.equals(this.becomeEnabled, adHocCommandList.becomeEnabled) &&
        Objects.equals(this.diffMode, adHocCommandList.diffMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, url, related, summaryFields, created, modified, name, launchType, status, executionEnvironment, failed, started, finished, canceledOn, elapsed, jobExplanation, executionNode, controllerNode, launchedBy, workUnitId, jobType, inventory, limit, credential, moduleName, moduleArgs, forks, verbosity, extraVars, becomeEnabled, diffMode);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AdHocCommandList {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    related: ").append(toIndentedString(related)).append("\n");
    sb.append("    summaryFields: ").append(toIndentedString(summaryFields)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    launchType: ").append(toIndentedString(launchType)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    executionEnvironment: ").append(toIndentedString(executionEnvironment)).append("\n");
    sb.append("    failed: ").append(toIndentedString(failed)).append("\n");
    sb.append("    started: ").append(toIndentedString(started)).append("\n");
    sb.append("    finished: ").append(toIndentedString(finished)).append("\n");
    sb.append("    canceledOn: ").append(toIndentedString(canceledOn)).append("\n");
    sb.append("    elapsed: ").append(toIndentedString(elapsed)).append("\n");
    sb.append("    jobExplanation: ").append(toIndentedString(jobExplanation)).append("\n");
    sb.append("    executionNode: ").append(toIndentedString(executionNode)).append("\n");
    sb.append("    controllerNode: ").append(toIndentedString(controllerNode)).append("\n");
    sb.append("    launchedBy: ").append(toIndentedString(launchedBy)).append("\n");
    sb.append("    workUnitId: ").append(toIndentedString(workUnitId)).append("\n");
    sb.append("    jobType: ").append(toIndentedString(jobType)).append("\n");
    sb.append("    inventory: ").append(toIndentedString(inventory)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    credential: ").append(toIndentedString(credential)).append("\n");
    sb.append("    moduleName: ").append(toIndentedString(moduleName)).append("\n");
    sb.append("    moduleArgs: ").append(toIndentedString(moduleArgs)).append("\n");
    sb.append("    forks: ").append(toIndentedString(forks)).append("\n");
    sb.append("    verbosity: ").append(toIndentedString(verbosity)).append("\n");
    sb.append("    extraVars: ").append(toIndentedString(extraVars)).append("\n");
    sb.append("    becomeEnabled: ").append(toIndentedString(becomeEnabled)).append("\n");
    sb.append("    diffMode: ").append(toIndentedString(diffMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

/*
 * Snippets API
 * Test description
 *
 * OpenAPI spec version: v1
 * Contact: contact@snippets.local
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.limix.awx.api.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.limix.awx.api.model.LaunchedBy;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import org.threeten.bp.OffsetDateTime;
/**
 * InventoryUpdateDetail
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-05-25T17:26:39.970+08:00[Asia/Shanghai]")
public class InventoryUpdateDetail {
  @SerializedName("id")
  private Integer id = null;

  @SerializedName("type")
  private String type = null;

  @SerializedName("url")
  private String url = null;

  @SerializedName("related")
  private Object related = null;

  @SerializedName("summary_fields")
  private Object summaryFields = null;

  @SerializedName("created")
  private String created = null;

  @SerializedName("modified")
  private String modified = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = "";

  /**
   * Gets or Sets source
   */
  @JsonAdapter(SourceEnum.Adapter.class)
  public enum SourceEnum {
    FILE("file"),
    SCM("scm"),
    EC2("ec2"),
    GCE("gce"),
    AZURE_RM("azure_rm"),
    VMWARE("vmware"),
    SATELLITE6("satellite6"),
    OPENSTACK("openstack"),
    RHV("rhv"),
    CONTROLLER("controller"),
    INSIGHTS("insights");

    private String value;

    SourceEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SourceEnum fromValue(String input) {
      for (SourceEnum b : SourceEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SourceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SourceEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public SourceEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return SourceEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("source")
  private SourceEnum source = null;

  @SerializedName("source_path")
  private String sourcePath = "";

  @SerializedName("source_vars")
  private String sourceVars = "";

  @SerializedName("credential")
  private Integer credential = null;

  @SerializedName("enabled_var")
  private String enabledVar = "";

  @SerializedName("enabled_value")
  private String enabledValue = "";

  @SerializedName("host_filter")
  private String hostFilter = "";

  @SerializedName("overwrite")
  private Boolean overwrite = false;

  @SerializedName("overwrite_vars")
  private Boolean overwriteVars = false;

  @SerializedName("custom_virtualenv")
  private String customVirtualenv = null;

  @SerializedName("timeout")
  private Integer timeout = null;

  @SerializedName("verbosity")
  private Integer verbosity = null;

  @SerializedName("unified_job_template")
  private String unifiedJobTemplate = null;

  /**
   * Gets or Sets launchType
   */
  @JsonAdapter(LaunchTypeEnum.Adapter.class)
  public enum LaunchTypeEnum {
    MANUAL("manual"),
    RELAUNCH("relaunch"),
    CALLBACK("callback"),
    SCHEDULED("scheduled"),
    DEPENDENCY("dependency"),
    WORKFLOW("workflow"),
    WEBHOOK("webhook"),
    SYNC("sync"),
    SCM("scm");

    private String value;

    LaunchTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LaunchTypeEnum fromValue(String input) {
      for (LaunchTypeEnum b : LaunchTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LaunchTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LaunchTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public LaunchTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LaunchTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("launch_type")
  private LaunchTypeEnum launchType = null;

  /**
   * Gets or Sets status
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    NEW("new"),
    PENDING("pending"),
    WAITING("waiting"),
    RUNNING("running"),
    SUCCESSFUL("successful"),
    FAILED("failed"),
    ERROR("error"),
    CANCELED("canceled");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String input) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StatusEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("status")
  private StatusEnum status = null;

  @SerializedName("execution_environment")
  private Integer executionEnvironment = null;

  @SerializedName("failed")
  private Boolean failed = null;

  @SerializedName("started")
  private OffsetDateTime started = null;

  @SerializedName("finished")
  private OffsetDateTime finished = null;

  @SerializedName("canceled_on")
  private OffsetDateTime canceledOn = null;

  @SerializedName("elapsed")
  private String elapsed = null;

  @SerializedName("job_args")
  private String jobArgs = null;

  @SerializedName("job_cwd")
  private String jobCwd = null;

  @SerializedName("job_env")
  private Object jobEnv = null;

  @SerializedName("job_explanation")
  private String jobExplanation = null;

  @SerializedName("execution_node")
  private String executionNode = null;

  @SerializedName("result_traceback")
  private String resultTraceback = null;

  @SerializedName("event_processing_finished")
  private Boolean eventProcessingFinished = null;

  @SerializedName("launched_by")
  private LaunchedBy launchedBy = null;

  @SerializedName("work_unit_id")
  private String workUnitId = null;

  @SerializedName("inventory")
  private Integer inventory = null;

  @SerializedName("inventory_source")
  private String inventorySource = null;

  @SerializedName("license_error")
  private Boolean licenseError = null;

  @SerializedName("org_host_limit_error")
  private Boolean orgHostLimitError = null;

  @SerializedName("source_project_update")
  private String sourceProjectUpdate = null;

  @SerializedName("instance_group")
  private Integer instanceGroup = null;

  @SerializedName("source_project")
  private String sourceProject = null;

   /**
   * Get id
   * @return id
  **/
  @Schema(description = "")
  public Integer getId() {
    return id;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public String getType() {
    return type;
  }

   /**
   * Get url
   * @return url
  **/
  @Schema(description = "")
  public String getUrl() {
    return url;
  }

  public InventoryUpdateDetail related(Object related) {
    this.related = related;
    return this;
  }

   /**
   * Get related
   * @return related
  **/
  @Schema(description = "")
  public Object getRelated() {
    return related;
  }

  public void setRelated(Object related) {
    this.related = related;
  }

  public InventoryUpdateDetail summaryFields(Object summaryFields) {
    this.summaryFields = summaryFields;
    return this;
  }

   /**
   * Get summaryFields
   * @return summaryFields
  **/
  @Schema(description = "")
  public Object getSummaryFields() {
    return summaryFields;
  }

  public void setSummaryFields(Object summaryFields) {
    this.summaryFields = summaryFields;
  }

   /**
   * Get created
   * @return created
  **/
  @Schema(description = "")
  public String getCreated() {
    return created;
  }

   /**
   * Get modified
   * @return modified
  **/
  @Schema(description = "")
  public String getModified() {
    return modified;
  }

  public InventoryUpdateDetail name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @Schema(required = true, description = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public InventoryUpdateDetail description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Get description
   * @return description
  **/
  @Schema(description = "")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public InventoryUpdateDetail source(SourceEnum source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @Schema(description = "")
  public SourceEnum getSource() {
    return source;
  }

  public void setSource(SourceEnum source) {
    this.source = source;
  }

  public InventoryUpdateDetail sourcePath(String sourcePath) {
    this.sourcePath = sourcePath;
    return this;
  }

   /**
   * Get sourcePath
   * @return sourcePath
  **/
  @Schema(description = "")
  public String getSourcePath() {
    return sourcePath;
  }

  public void setSourcePath(String sourcePath) {
    this.sourcePath = sourcePath;
  }

  public InventoryUpdateDetail sourceVars(String sourceVars) {
    this.sourceVars = sourceVars;
    return this;
  }

   /**
   * Inventory source variables in YAML or JSON format.
   * @return sourceVars
  **/
  @Schema(description = "Inventory source variables in YAML or JSON format.")
  public String getSourceVars() {
    return sourceVars;
  }

  public void setSourceVars(String sourceVars) {
    this.sourceVars = sourceVars;
  }

  public InventoryUpdateDetail credential(Integer credential) {
    this.credential = credential;
    return this;
  }

   /**
   * Cloud credential to use for inventory updates.
   * minimum: 1
   * @return credential
  **/
  @Schema(description = "Cloud credential to use for inventory updates.")
  public Integer getCredential() {
    return credential;
  }

  public void setCredential(Integer credential) {
    this.credential = credential;
  }

  public InventoryUpdateDetail enabledVar(String enabledVar) {
    this.enabledVar = enabledVar;
    return this;
  }

   /**
   * Retrieve the enabled state from the given dict of host variables. The enabled variable may be specified as \&quot;foo.bar\&quot;, in which case the lookup will traverse into nested dicts, equivalent to: from_dict.get(\&quot;foo\&quot;, {}).get(\&quot;bar\&quot;, default)
   * @return enabledVar
  **/
  @Schema(description = "Retrieve the enabled state from the given dict of host variables. The enabled variable may be specified as \"foo.bar\", in which case the lookup will traverse into nested dicts, equivalent to: from_dict.get(\"foo\", {}).get(\"bar\", default)")
  public String getEnabledVar() {
    return enabledVar;
  }

  public void setEnabledVar(String enabledVar) {
    this.enabledVar = enabledVar;
  }

  public InventoryUpdateDetail enabledValue(String enabledValue) {
    this.enabledValue = enabledValue;
    return this;
  }

   /**
   * Only used when enabled_var is set. Value when the host is considered enabled. For example if enabled_var&#x3D;\&quot;status.power_state\&quot;and enabled_value&#x3D;\&quot;powered_on\&quot; with host variables:{   \&quot;status\&quot;: {     \&quot;power_state\&quot;: \&quot;powered_on\&quot;,     \&quot;created\&quot;: \&quot;2020-08-04T18:13:04+00:00\&quot;,     \&quot;healthy\&quot;: true    },    \&quot;name\&quot;: \&quot;foobar\&quot;,    \&quot;ip_address\&quot;: \&quot;192.168.2.1\&quot;}The host would be marked enabled. If power_state where any value other than powered_on then the host would be disabled when imported. If the key is not found then the host will be enabled
   * @return enabledValue
  **/
  @Schema(description = "Only used when enabled_var is set. Value when the host is considered enabled. For example if enabled_var=\"status.power_state\"and enabled_value=\"powered_on\" with host variables:{   \"status\": {     \"power_state\": \"powered_on\",     \"created\": \"2020-08-04T18:13:04+00:00\",     \"healthy\": true    },    \"name\": \"foobar\",    \"ip_address\": \"192.168.2.1\"}The host would be marked enabled. If power_state where any value other than powered_on then the host would be disabled when imported. If the key is not found then the host will be enabled")
  public String getEnabledValue() {
    return enabledValue;
  }

  public void setEnabledValue(String enabledValue) {
    this.enabledValue = enabledValue;
  }

  public InventoryUpdateDetail hostFilter(String hostFilter) {
    this.hostFilter = hostFilter;
    return this;
  }

   /**
   * Regex where only matching hosts will be imported.
   * @return hostFilter
  **/
  @Schema(description = "Regex where only matching hosts will be imported.")
  public String getHostFilter() {
    return hostFilter;
  }

  public void setHostFilter(String hostFilter) {
    this.hostFilter = hostFilter;
  }

  public InventoryUpdateDetail overwrite(Boolean overwrite) {
    this.overwrite = overwrite;
    return this;
  }

   /**
   * Overwrite local groups and hosts from remote inventory source.
   * @return overwrite
  **/
  @Schema(description = "Overwrite local groups and hosts from remote inventory source.")
  public Boolean isOverwrite() {
    return overwrite;
  }

  public void setOverwrite(Boolean overwrite) {
    this.overwrite = overwrite;
  }

  public InventoryUpdateDetail overwriteVars(Boolean overwriteVars) {
    this.overwriteVars = overwriteVars;
    return this;
  }

   /**
   * Overwrite local variables from remote inventory source.
   * @return overwriteVars
  **/
  @Schema(description = "Overwrite local variables from remote inventory source.")
  public Boolean isOverwriteVars() {
    return overwriteVars;
  }

  public void setOverwriteVars(Boolean overwriteVars) {
    this.overwriteVars = overwriteVars;
  }

   /**
   * Get customVirtualenv
   * @return customVirtualenv
  **/
  @Schema(description = "")
  public String getCustomVirtualenv() {
    return customVirtualenv;
  }

  public InventoryUpdateDetail timeout(Integer timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * The amount of time (in seconds) to run before the task is canceled.
   * minimum: -2147483648
   * maximum: 2147483647
   * @return timeout
  **/
  @Schema(description = "The amount of time (in seconds) to run before the task is canceled.")
  public Integer getTimeout() {
    return timeout;
  }

  public void setTimeout(Integer timeout) {
    this.timeout = timeout;
  }

  public InventoryUpdateDetail verbosity(Integer verbosity) {
    this.verbosity = verbosity;
    return this;
  }

   /**
   * Get verbosity
   * @return verbosity
  **/
  @Schema(description = "")
  public Integer getVerbosity() {
    return verbosity;
  }

  public void setVerbosity(Integer verbosity) {
    this.verbosity = verbosity;
  }

   /**
   * Get unifiedJobTemplate
   * @return unifiedJobTemplate
  **/
  @Schema(description = "")
  public String getUnifiedJobTemplate() {
    return unifiedJobTemplate;
  }

   /**
   * Get launchType
   * @return launchType
  **/
  @Schema(description = "")
  public LaunchTypeEnum getLaunchType() {
    return launchType;
  }

   /**
   * Get status
   * @return status
  **/
  @Schema(description = "")
  public StatusEnum getStatus() {
    return status;
  }

  public InventoryUpdateDetail executionEnvironment(Integer executionEnvironment) {
    this.executionEnvironment = executionEnvironment;
    return this;
  }

   /**
   * The container image to be used for execution.
   * @return executionEnvironment
  **/
  @Schema(description = "The container image to be used for execution.")
  public Integer getExecutionEnvironment() {
    return executionEnvironment;
  }

  public void setExecutionEnvironment(Integer executionEnvironment) {
    this.executionEnvironment = executionEnvironment;
  }

   /**
   * Get failed
   * @return failed
  **/
  @Schema(description = "")
  public Boolean isFailed() {
    return failed;
  }

   /**
   * The date and time the job was queued for starting.
   * @return started
  **/
  @Schema(description = "The date and time the job was queued for starting.")
  public OffsetDateTime getStarted() {
    return started;
  }

   /**
   * The date and time the job finished execution.
   * @return finished
  **/
  @Schema(description = "The date and time the job finished execution.")
  public OffsetDateTime getFinished() {
    return finished;
  }

   /**
   * The date and time when the cancel request was sent.
   * @return canceledOn
  **/
  @Schema(description = "The date and time when the cancel request was sent.")
  public OffsetDateTime getCanceledOn() {
    return canceledOn;
  }

   /**
   * Elapsed time in seconds that the job ran.
   * @return elapsed
  **/
  @Schema(description = "Elapsed time in seconds that the job ran.")
  public String getElapsed() {
    return elapsed;
  }

   /**
   * Get jobArgs
   * @return jobArgs
  **/
  @Schema(description = "")
  public String getJobArgs() {
    return jobArgs;
  }

   /**
   * Get jobCwd
   * @return jobCwd
  **/
  @Schema(description = "")
  public String getJobCwd() {
    return jobCwd;
  }

   /**
   * Get jobEnv
   * @return jobEnv
  **/
  @Schema(description = "")
  public Object getJobEnv() {
    return jobEnv;
  }

   /**
   * A status field to indicate the state of the job if it wasn&#x27;t able to run and capture stdout
   * @return jobExplanation
  **/
  @Schema(description = "A status field to indicate the state of the job if it wasn't able to run and capture stdout")
  public String getJobExplanation() {
    return jobExplanation;
  }

   /**
   * The node the job executed on.
   * @return executionNode
  **/
  @Schema(description = "The node the job executed on.")
  public String getExecutionNode() {
    return executionNode;
  }

   /**
   * Get resultTraceback
   * @return resultTraceback
  **/
  @Schema(description = "")
  public String getResultTraceback() {
    return resultTraceback;
  }

   /**
   * Indicates whether all of the events generated by this unified job have been saved to the database.
   * @return eventProcessingFinished
  **/
  @Schema(description = "Indicates whether all of the events generated by this unified job have been saved to the database.")
  public Boolean isEventProcessingFinished() {
    return eventProcessingFinished;
  }

  public InventoryUpdateDetail launchedBy(LaunchedBy launchedBy) {
    this.launchedBy = launchedBy;
    return this;
  }

   /**
   * Get launchedBy
   * @return launchedBy
  **/
  @Schema(description = "")
  public LaunchedBy getLaunchedBy() {
    return launchedBy;
  }

  public void setLaunchedBy(LaunchedBy launchedBy) {
    this.launchedBy = launchedBy;
  }

   /**
   * The Receptor work unit ID associated with this job.
   * @return workUnitId
  **/
  @Schema(description = "The Receptor work unit ID associated with this job.")
  public String getWorkUnitId() {
    return workUnitId;
  }

  public InventoryUpdateDetail inventory(Integer inventory) {
    this.inventory = inventory;
    return this;
  }

   /**
   * Get inventory
   * @return inventory
  **/
  @Schema(description = "")
  public Integer getInventory() {
    return inventory;
  }

  public void setInventory(Integer inventory) {
    this.inventory = inventory;
  }

   /**
   * Get inventorySource
   * @return inventorySource
  **/
  @Schema(description = "")
  public String getInventorySource() {
    return inventorySource;
  }

   /**
   * Get licenseError
   * @return licenseError
  **/
  @Schema(description = "")
  public Boolean isLicenseError() {
    return licenseError;
  }

   /**
   * Get orgHostLimitError
   * @return orgHostLimitError
  **/
  @Schema(description = "")
  public Boolean isOrgHostLimitError() {
    return orgHostLimitError;
  }

  public InventoryUpdateDetail sourceProjectUpdate(String sourceProjectUpdate) {
    this.sourceProjectUpdate = sourceProjectUpdate;
    return this;
  }

   /**
   * Inventory files from this Project Update were used for the inventory update.
   * @return sourceProjectUpdate
  **/
  @Schema(description = "Inventory files from this Project Update were used for the inventory update.")
  public String getSourceProjectUpdate() {
    return sourceProjectUpdate;
  }

  public void setSourceProjectUpdate(String sourceProjectUpdate) {
    this.sourceProjectUpdate = sourceProjectUpdate;
  }

  public InventoryUpdateDetail instanceGroup(Integer instanceGroup) {
    this.instanceGroup = instanceGroup;
    return this;
  }

   /**
   * The Instance group the job was run under
   * @return instanceGroup
  **/
  @Schema(description = "The Instance group the job was run under")
  public Integer getInstanceGroup() {
    return instanceGroup;
  }

  public void setInstanceGroup(Integer instanceGroup) {
    this.instanceGroup = instanceGroup;
  }

   /**
   * The project used for this job.
   * @return sourceProject
  **/
  @Schema(description = "The project used for this job.")
  public String getSourceProject() {
    return sourceProject;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InventoryUpdateDetail inventoryUpdateDetail = (InventoryUpdateDetail) o;
    return Objects.equals(this.id, inventoryUpdateDetail.id) &&
        Objects.equals(this.type, inventoryUpdateDetail.type) &&
        Objects.equals(this.url, inventoryUpdateDetail.url) &&
        Objects.equals(this.related, inventoryUpdateDetail.related) &&
        Objects.equals(this.summaryFields, inventoryUpdateDetail.summaryFields) &&
        Objects.equals(this.created, inventoryUpdateDetail.created) &&
        Objects.equals(this.modified, inventoryUpdateDetail.modified) &&
        Objects.equals(this.name, inventoryUpdateDetail.name) &&
        Objects.equals(this.description, inventoryUpdateDetail.description) &&
        Objects.equals(this.source, inventoryUpdateDetail.source) &&
        Objects.equals(this.sourcePath, inventoryUpdateDetail.sourcePath) &&
        Objects.equals(this.sourceVars, inventoryUpdateDetail.sourceVars) &&
        Objects.equals(this.credential, inventoryUpdateDetail.credential) &&
        Objects.equals(this.enabledVar, inventoryUpdateDetail.enabledVar) &&
        Objects.equals(this.enabledValue, inventoryUpdateDetail.enabledValue) &&
        Objects.equals(this.hostFilter, inventoryUpdateDetail.hostFilter) &&
        Objects.equals(this.overwrite, inventoryUpdateDetail.overwrite) &&
        Objects.equals(this.overwriteVars, inventoryUpdateDetail.overwriteVars) &&
        Objects.equals(this.customVirtualenv, inventoryUpdateDetail.customVirtualenv) &&
        Objects.equals(this.timeout, inventoryUpdateDetail.timeout) &&
        Objects.equals(this.verbosity, inventoryUpdateDetail.verbosity) &&
        Objects.equals(this.unifiedJobTemplate, inventoryUpdateDetail.unifiedJobTemplate) &&
        Objects.equals(this.launchType, inventoryUpdateDetail.launchType) &&
        Objects.equals(this.status, inventoryUpdateDetail.status) &&
        Objects.equals(this.executionEnvironment, inventoryUpdateDetail.executionEnvironment) &&
        Objects.equals(this.failed, inventoryUpdateDetail.failed) &&
        Objects.equals(this.started, inventoryUpdateDetail.started) &&
        Objects.equals(this.finished, inventoryUpdateDetail.finished) &&
        Objects.equals(this.canceledOn, inventoryUpdateDetail.canceledOn) &&
        Objects.equals(this.elapsed, inventoryUpdateDetail.elapsed) &&
        Objects.equals(this.jobArgs, inventoryUpdateDetail.jobArgs) &&
        Objects.equals(this.jobCwd, inventoryUpdateDetail.jobCwd) &&
        Objects.equals(this.jobEnv, inventoryUpdateDetail.jobEnv) &&
        Objects.equals(this.jobExplanation, inventoryUpdateDetail.jobExplanation) &&
        Objects.equals(this.executionNode, inventoryUpdateDetail.executionNode) &&
        Objects.equals(this.resultTraceback, inventoryUpdateDetail.resultTraceback) &&
        Objects.equals(this.eventProcessingFinished, inventoryUpdateDetail.eventProcessingFinished) &&
        Objects.equals(this.launchedBy, inventoryUpdateDetail.launchedBy) &&
        Objects.equals(this.workUnitId, inventoryUpdateDetail.workUnitId) &&
        Objects.equals(this.inventory, inventoryUpdateDetail.inventory) &&
        Objects.equals(this.inventorySource, inventoryUpdateDetail.inventorySource) &&
        Objects.equals(this.licenseError, inventoryUpdateDetail.licenseError) &&
        Objects.equals(this.orgHostLimitError, inventoryUpdateDetail.orgHostLimitError) &&
        Objects.equals(this.sourceProjectUpdate, inventoryUpdateDetail.sourceProjectUpdate) &&
        Objects.equals(this.instanceGroup, inventoryUpdateDetail.instanceGroup) &&
        Objects.equals(this.sourceProject, inventoryUpdateDetail.sourceProject);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, url, related, summaryFields, created, modified, name, description, source, sourcePath, sourceVars, credential, enabledVar, enabledValue, hostFilter, overwrite, overwriteVars, customVirtualenv, timeout, verbosity, unifiedJobTemplate, launchType, status, executionEnvironment, failed, started, finished, canceledOn, elapsed, jobArgs, jobCwd, jobEnv, jobExplanation, executionNode, resultTraceback, eventProcessingFinished, launchedBy, workUnitId, inventory, inventorySource, licenseError, orgHostLimitError, sourceProjectUpdate, instanceGroup, sourceProject);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InventoryUpdateDetail {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    related: ").append(toIndentedString(related)).append("\n");
    sb.append("    summaryFields: ").append(toIndentedString(summaryFields)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    sourcePath: ").append(toIndentedString(sourcePath)).append("\n");
    sb.append("    sourceVars: ").append(toIndentedString(sourceVars)).append("\n");
    sb.append("    credential: ").append(toIndentedString(credential)).append("\n");
    sb.append("    enabledVar: ").append(toIndentedString(enabledVar)).append("\n");
    sb.append("    enabledValue: ").append(toIndentedString(enabledValue)).append("\n");
    sb.append("    hostFilter: ").append(toIndentedString(hostFilter)).append("\n");
    sb.append("    overwrite: ").append(toIndentedString(overwrite)).append("\n");
    sb.append("    overwriteVars: ").append(toIndentedString(overwriteVars)).append("\n");
    sb.append("    customVirtualenv: ").append(toIndentedString(customVirtualenv)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    verbosity: ").append(toIndentedString(verbosity)).append("\n");
    sb.append("    unifiedJobTemplate: ").append(toIndentedString(unifiedJobTemplate)).append("\n");
    sb.append("    launchType: ").append(toIndentedString(launchType)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    executionEnvironment: ").append(toIndentedString(executionEnvironment)).append("\n");
    sb.append("    failed: ").append(toIndentedString(failed)).append("\n");
    sb.append("    started: ").append(toIndentedString(started)).append("\n");
    sb.append("    finished: ").append(toIndentedString(finished)).append("\n");
    sb.append("    canceledOn: ").append(toIndentedString(canceledOn)).append("\n");
    sb.append("    elapsed: ").append(toIndentedString(elapsed)).append("\n");
    sb.append("    jobArgs: ").append(toIndentedString(jobArgs)).append("\n");
    sb.append("    jobCwd: ").append(toIndentedString(jobCwd)).append("\n");
    sb.append("    jobEnv: ").append(toIndentedString(jobEnv)).append("\n");
    sb.append("    jobExplanation: ").append(toIndentedString(jobExplanation)).append("\n");
    sb.append("    executionNode: ").append(toIndentedString(executionNode)).append("\n");
    sb.append("    resultTraceback: ").append(toIndentedString(resultTraceback)).append("\n");
    sb.append("    eventProcessingFinished: ").append(toIndentedString(eventProcessingFinished)).append("\n");
    sb.append("    launchedBy: ").append(toIndentedString(launchedBy)).append("\n");
    sb.append("    workUnitId: ").append(toIndentedString(workUnitId)).append("\n");
    sb.append("    inventory: ").append(toIndentedString(inventory)).append("\n");
    sb.append("    inventorySource: ").append(toIndentedString(inventorySource)).append("\n");
    sb.append("    licenseError: ").append(toIndentedString(licenseError)).append("\n");
    sb.append("    orgHostLimitError: ").append(toIndentedString(orgHostLimitError)).append("\n");
    sb.append("    sourceProjectUpdate: ").append(toIndentedString(sourceProjectUpdate)).append("\n");
    sb.append("    instanceGroup: ").append(toIndentedString(instanceGroup)).append("\n");
    sb.append("    sourceProject: ").append(toIndentedString(sourceProject)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

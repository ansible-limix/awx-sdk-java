/*
 * Snippets API
 * Test description
 *
 * OpenAPI spec version: v1
 * Contact: contact@snippets.local
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.limix.awx.api.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.limix.awx.api.model.LaunchedBy;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import org.threeten.bp.OffsetDateTime;
/**
 * JobList
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-05-25T17:26:39.970+08:00[Asia/Shanghai]")
public class JobList {
  @SerializedName("id")
  private Integer id = null;

  @SerializedName("type")
  private String type = null;

  @SerializedName("url")
  private String url = null;

  @SerializedName("related")
  private Object related = null;

  @SerializedName("summary_fields")
  private Object summaryFields = null;

  @SerializedName("created")
  private String created = null;

  @SerializedName("modified")
  private String modified = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = "";

  @SerializedName("unified_job_template")
  private String unifiedJobTemplate = null;

  /**
   * Gets or Sets launchType
   */
  @JsonAdapter(LaunchTypeEnum.Adapter.class)
  public enum LaunchTypeEnum {
    MANUAL("manual"),
    RELAUNCH("relaunch"),
    CALLBACK("callback"),
    SCHEDULED("scheduled"),
    DEPENDENCY("dependency"),
    WORKFLOW("workflow"),
    WEBHOOK("webhook"),
    SYNC("sync"),
    SCM("scm");

    private String value;

    LaunchTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LaunchTypeEnum fromValue(String input) {
      for (LaunchTypeEnum b : LaunchTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LaunchTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LaunchTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public LaunchTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LaunchTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("launch_type")
  private LaunchTypeEnum launchType = null;

  /**
   * Gets or Sets status
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    NEW("new"),
    PENDING("pending"),
    WAITING("waiting"),
    RUNNING("running"),
    SUCCESSFUL("successful"),
    FAILED("failed"),
    ERROR("error"),
    CANCELED("canceled");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String input) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StatusEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("status")
  private StatusEnum status = null;

  @SerializedName("execution_environment")
  private Integer executionEnvironment = null;

  @SerializedName("failed")
  private Boolean failed = null;

  @SerializedName("started")
  private OffsetDateTime started = null;

  @SerializedName("finished")
  private OffsetDateTime finished = null;

  @SerializedName("canceled_on")
  private OffsetDateTime canceledOn = null;

  @SerializedName("elapsed")
  private String elapsed = null;

  @SerializedName("job_explanation")
  private String jobExplanation = null;

  @SerializedName("execution_node")
  private String executionNode = null;

  @SerializedName("controller_node")
  private String controllerNode = null;

  @SerializedName("launched_by")
  private LaunchedBy launchedBy = null;

  @SerializedName("work_unit_id")
  private String workUnitId = null;

  /**
   * Gets or Sets jobType
   */
  @JsonAdapter(JobTypeEnum.Adapter.class)
  public enum JobTypeEnum {
    RUN("run"),
    CHECK("check"),
    SCAN("scan");

    private String value;

    JobTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static JobTypeEnum fromValue(String input) {
      for (JobTypeEnum b : JobTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<JobTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JobTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public JobTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return JobTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("job_type")
  private JobTypeEnum jobType = JobTypeEnum.RUN;

  @SerializedName("inventory")
  private Integer inventory = null;

  @SerializedName("project")
  private String project = null;

  @SerializedName("playbook")
  private String playbook = "";

  @SerializedName("scm_branch")
  private String scmBranch = "";

  @SerializedName("forks")
  private Integer forks = null;

  @SerializedName("limit")
  private String limit = "";

  @SerializedName("verbosity")
  private Integer verbosity = null;

  @SerializedName("extra_vars")
  private String extraVars = "";

  @SerializedName("job_tags")
  private String jobTags = "";

  @SerializedName("force_handlers")
  private Boolean forceHandlers = false;

  @SerializedName("skip_tags")
  private String skipTags = "";

  @SerializedName("start_at_task")
  private String startAtTask = "";

  @SerializedName("timeout")
  private Integer timeout = null;

  @SerializedName("use_fact_cache")
  private Boolean useFactCache = false;

  @SerializedName("organization")
  private Integer organization = null;

  @SerializedName("job_template")
  private String jobTemplate = null;

  @SerializedName("passwords_needed_to_start")
  private String passwordsNeededToStart = null;

  @SerializedName("allow_simultaneous")
  private Boolean allowSimultaneous = false;

  @SerializedName("artifacts")
  private String artifacts = null;

  @SerializedName("scm_revision")
  private String scmRevision = null;

  @SerializedName("instance_group")
  private Integer instanceGroup = null;

  @SerializedName("diff_mode")
  private Boolean diffMode = false;

  @SerializedName("job_slice_number")
  private Integer jobSliceNumber = null;

  @SerializedName("job_slice_count")
  private Integer jobSliceCount = null;

  /**
   * Service that webhook requests will be accepted from
   */
  @JsonAdapter(WebhookServiceEnum.Adapter.class)
  public enum WebhookServiceEnum {
    GITHUB("github"),
    GITLAB("gitlab");

    private String value;

    WebhookServiceEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static WebhookServiceEnum fromValue(String input) {
      for (WebhookServiceEnum b : WebhookServiceEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<WebhookServiceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WebhookServiceEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public WebhookServiceEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return WebhookServiceEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("webhook_service")
  private WebhookServiceEnum webhookService = null;

  @SerializedName("webhook_credential")
  private Integer webhookCredential = null;

  @SerializedName("webhook_guid")
  private String webhookGuid = null;

   /**
   * Get id
   * @return id
  **/
  @Schema(description = "")
  public Integer getId() {
    return id;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public String getType() {
    return type;
  }

   /**
   * Get url
   * @return url
  **/
  @Schema(description = "")
  public String getUrl() {
    return url;
  }

  public JobList related(Object related) {
    this.related = related;
    return this;
  }

   /**
   * Get related
   * @return related
  **/
  @Schema(description = "")
  public Object getRelated() {
    return related;
  }

  public void setRelated(Object related) {
    this.related = related;
  }

  public JobList summaryFields(Object summaryFields) {
    this.summaryFields = summaryFields;
    return this;
  }

   /**
   * Get summaryFields
   * @return summaryFields
  **/
  @Schema(description = "")
  public Object getSummaryFields() {
    return summaryFields;
  }

  public void setSummaryFields(Object summaryFields) {
    this.summaryFields = summaryFields;
  }

   /**
   * Get created
   * @return created
  **/
  @Schema(description = "")
  public String getCreated() {
    return created;
  }

   /**
   * Get modified
   * @return modified
  **/
  @Schema(description = "")
  public String getModified() {
    return modified;
  }

  public JobList name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @Schema(required = true, description = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public JobList description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Get description
   * @return description
  **/
  @Schema(description = "")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

   /**
   * Get unifiedJobTemplate
   * @return unifiedJobTemplate
  **/
  @Schema(description = "")
  public String getUnifiedJobTemplate() {
    return unifiedJobTemplate;
  }

   /**
   * Get launchType
   * @return launchType
  **/
  @Schema(description = "")
  public LaunchTypeEnum getLaunchType() {
    return launchType;
  }

   /**
   * Get status
   * @return status
  **/
  @Schema(description = "")
  public StatusEnum getStatus() {
    return status;
  }

  public JobList executionEnvironment(Integer executionEnvironment) {
    this.executionEnvironment = executionEnvironment;
    return this;
  }

   /**
   * The container image to be used for execution.
   * @return executionEnvironment
  **/
  @Schema(description = "The container image to be used for execution.")
  public Integer getExecutionEnvironment() {
    return executionEnvironment;
  }

  public void setExecutionEnvironment(Integer executionEnvironment) {
    this.executionEnvironment = executionEnvironment;
  }

   /**
   * Get failed
   * @return failed
  **/
  @Schema(description = "")
  public Boolean isFailed() {
    return failed;
  }

   /**
   * The date and time the job was queued for starting.
   * @return started
  **/
  @Schema(description = "The date and time the job was queued for starting.")
  public OffsetDateTime getStarted() {
    return started;
  }

   /**
   * The date and time the job finished execution.
   * @return finished
  **/
  @Schema(description = "The date and time the job finished execution.")
  public OffsetDateTime getFinished() {
    return finished;
  }

   /**
   * The date and time when the cancel request was sent.
   * @return canceledOn
  **/
  @Schema(description = "The date and time when the cancel request was sent.")
  public OffsetDateTime getCanceledOn() {
    return canceledOn;
  }

   /**
   * Elapsed time in seconds that the job ran.
   * @return elapsed
  **/
  @Schema(description = "Elapsed time in seconds that the job ran.")
  public String getElapsed() {
    return elapsed;
  }

   /**
   * A status field to indicate the state of the job if it wasn&#x27;t able to run and capture stdout
   * @return jobExplanation
  **/
  @Schema(description = "A status field to indicate the state of the job if it wasn't able to run and capture stdout")
  public String getJobExplanation() {
    return jobExplanation;
  }

   /**
   * The node the job executed on.
   * @return executionNode
  **/
  @Schema(description = "The node the job executed on.")
  public String getExecutionNode() {
    return executionNode;
  }

   /**
   * The instance that managed the execution environment.
   * @return controllerNode
  **/
  @Schema(description = "The instance that managed the execution environment.")
  public String getControllerNode() {
    return controllerNode;
  }

  public JobList launchedBy(LaunchedBy launchedBy) {
    this.launchedBy = launchedBy;
    return this;
  }

   /**
   * Get launchedBy
   * @return launchedBy
  **/
  @Schema(description = "")
  public LaunchedBy getLaunchedBy() {
    return launchedBy;
  }

  public void setLaunchedBy(LaunchedBy launchedBy) {
    this.launchedBy = launchedBy;
  }

   /**
   * The Receptor work unit ID associated with this job.
   * @return workUnitId
  **/
  @Schema(description = "The Receptor work unit ID associated with this job.")
  public String getWorkUnitId() {
    return workUnitId;
  }

  public JobList jobType(JobTypeEnum jobType) {
    this.jobType = jobType;
    return this;
  }

   /**
   * Get jobType
   * @return jobType
  **/
  @Schema(description = "")
  public JobTypeEnum getJobType() {
    return jobType;
  }

  public void setJobType(JobTypeEnum jobType) {
    this.jobType = jobType;
  }

  public JobList inventory(Integer inventory) {
    this.inventory = inventory;
    return this;
  }

   /**
   * Get inventory
   * @return inventory
  **/
  @Schema(description = "")
  public Integer getInventory() {
    return inventory;
  }

  public void setInventory(Integer inventory) {
    this.inventory = inventory;
  }

  public JobList project(String project) {
    this.project = project;
    return this;
  }

   /**
   * Get project
   * @return project
  **/
  @Schema(description = "")
  public String getProject() {
    return project;
  }

  public void setProject(String project) {
    this.project = project;
  }

  public JobList playbook(String playbook) {
    this.playbook = playbook;
    return this;
  }

   /**
   * Get playbook
   * @return playbook
  **/
  @Schema(description = "")
  public String getPlaybook() {
    return playbook;
  }

  public void setPlaybook(String playbook) {
    this.playbook = playbook;
  }

  public JobList scmBranch(String scmBranch) {
    this.scmBranch = scmBranch;
    return this;
  }

   /**
   * Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true.
   * @return scmBranch
  **/
  @Schema(description = "Branch to use in job run. Project default used if blank. Only allowed if project allow_override field is set to true.")
  public String getScmBranch() {
    return scmBranch;
  }

  public void setScmBranch(String scmBranch) {
    this.scmBranch = scmBranch;
  }

  public JobList forks(Integer forks) {
    this.forks = forks;
    return this;
  }

   /**
   * Get forks
   * minimum: 0
   * maximum: 2147483647
   * @return forks
  **/
  @Schema(description = "")
  public Integer getForks() {
    return forks;
  }

  public void setForks(Integer forks) {
    this.forks = forks;
  }

  public JobList limit(String limit) {
    this.limit = limit;
    return this;
  }

   /**
   * Get limit
   * @return limit
  **/
  @Schema(description = "")
  public String getLimit() {
    return limit;
  }

  public void setLimit(String limit) {
    this.limit = limit;
  }

  public JobList verbosity(Integer verbosity) {
    this.verbosity = verbosity;
    return this;
  }

   /**
   * Get verbosity
   * @return verbosity
  **/
  @Schema(description = "")
  public Integer getVerbosity() {
    return verbosity;
  }

  public void setVerbosity(Integer verbosity) {
    this.verbosity = verbosity;
  }

  public JobList extraVars(String extraVars) {
    this.extraVars = extraVars;
    return this;
  }

   /**
   * Get extraVars
   * @return extraVars
  **/
  @Schema(description = "")
  public String getExtraVars() {
    return extraVars;
  }

  public void setExtraVars(String extraVars) {
    this.extraVars = extraVars;
  }

  public JobList jobTags(String jobTags) {
    this.jobTags = jobTags;
    return this;
  }

   /**
   * Get jobTags
   * @return jobTags
  **/
  @Schema(description = "")
  public String getJobTags() {
    return jobTags;
  }

  public void setJobTags(String jobTags) {
    this.jobTags = jobTags;
  }

  public JobList forceHandlers(Boolean forceHandlers) {
    this.forceHandlers = forceHandlers;
    return this;
  }

   /**
   * Get forceHandlers
   * @return forceHandlers
  **/
  @Schema(description = "")
  public Boolean isForceHandlers() {
    return forceHandlers;
  }

  public void setForceHandlers(Boolean forceHandlers) {
    this.forceHandlers = forceHandlers;
  }

  public JobList skipTags(String skipTags) {
    this.skipTags = skipTags;
    return this;
  }

   /**
   * Get skipTags
   * @return skipTags
  **/
  @Schema(description = "")
  public String getSkipTags() {
    return skipTags;
  }

  public void setSkipTags(String skipTags) {
    this.skipTags = skipTags;
  }

  public JobList startAtTask(String startAtTask) {
    this.startAtTask = startAtTask;
    return this;
  }

   /**
   * Get startAtTask
   * @return startAtTask
  **/
  @Schema(description = "")
  public String getStartAtTask() {
    return startAtTask;
  }

  public void setStartAtTask(String startAtTask) {
    this.startAtTask = startAtTask;
  }

  public JobList timeout(Integer timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * The amount of time (in seconds) to run before the task is canceled.
   * minimum: -2147483648
   * maximum: 2147483647
   * @return timeout
  **/
  @Schema(description = "The amount of time (in seconds) to run before the task is canceled.")
  public Integer getTimeout() {
    return timeout;
  }

  public void setTimeout(Integer timeout) {
    this.timeout = timeout;
  }

  public JobList useFactCache(Boolean useFactCache) {
    this.useFactCache = useFactCache;
    return this;
  }

   /**
   * If enabled, the service will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible.
   * @return useFactCache
  **/
  @Schema(description = "If enabled, the service will act as an Ansible Fact Cache Plugin; persisting facts at the end of a playbook run to the database and caching facts for use by Ansible.")
  public Boolean isUseFactCache() {
    return useFactCache;
  }

  public void setUseFactCache(Boolean useFactCache) {
    this.useFactCache = useFactCache;
  }

   /**
   * The organization used to determine access to this unified job.
   * @return organization
  **/
  @Schema(description = "The organization used to determine access to this unified job.")
  public Integer getOrganization() {
    return organization;
  }

  public JobList jobTemplate(String jobTemplate) {
    this.jobTemplate = jobTemplate;
    return this;
  }

   /**
   * Get jobTemplate
   * @return jobTemplate
  **/
  @Schema(description = "")
  public String getJobTemplate() {
    return jobTemplate;
  }

  public void setJobTemplate(String jobTemplate) {
    this.jobTemplate = jobTemplate;
  }

   /**
   * Get passwordsNeededToStart
   * @return passwordsNeededToStart
  **/
  @Schema(description = "")
  public String getPasswordsNeededToStart() {
    return passwordsNeededToStart;
  }

  public JobList allowSimultaneous(Boolean allowSimultaneous) {
    this.allowSimultaneous = allowSimultaneous;
    return this;
  }

   /**
   * Get allowSimultaneous
   * @return allowSimultaneous
  **/
  @Schema(description = "")
  public Boolean isAllowSimultaneous() {
    return allowSimultaneous;
  }

  public void setAllowSimultaneous(Boolean allowSimultaneous) {
    this.allowSimultaneous = allowSimultaneous;
  }

   /**
   * Get artifacts
   * @return artifacts
  **/
  @Schema(description = "")
  public String getArtifacts() {
    return artifacts;
  }

   /**
   * The SCM Revision from the Project used for this job, if available
   * @return scmRevision
  **/
  @Schema(description = "The SCM Revision from the Project used for this job, if available")
  public String getScmRevision() {
    return scmRevision;
  }

  public JobList instanceGroup(Integer instanceGroup) {
    this.instanceGroup = instanceGroup;
    return this;
  }

   /**
   * The Instance group the job was run under
   * @return instanceGroup
  **/
  @Schema(description = "The Instance group the job was run under")
  public Integer getInstanceGroup() {
    return instanceGroup;
  }

  public void setInstanceGroup(Integer instanceGroup) {
    this.instanceGroup = instanceGroup;
  }

  public JobList diffMode(Boolean diffMode) {
    this.diffMode = diffMode;
    return this;
  }

   /**
   * If enabled, textual changes made to any templated files on the host are shown in the standard output
   * @return diffMode
  **/
  @Schema(description = "If enabled, textual changes made to any templated files on the host are shown in the standard output")
  public Boolean isDiffMode() {
    return diffMode;
  }

  public void setDiffMode(Boolean diffMode) {
    this.diffMode = diffMode;
  }

  public JobList jobSliceNumber(Integer jobSliceNumber) {
    this.jobSliceNumber = jobSliceNumber;
    return this;
  }

   /**
   * If part of a sliced job, the ID of the inventory slice operated on. If not part of sliced job, parameter is not used.
   * minimum: 0
   * maximum: 2147483647
   * @return jobSliceNumber
  **/
  @Schema(description = "If part of a sliced job, the ID of the inventory slice operated on. If not part of sliced job, parameter is not used.")
  public Integer getJobSliceNumber() {
    return jobSliceNumber;
  }

  public void setJobSliceNumber(Integer jobSliceNumber) {
    this.jobSliceNumber = jobSliceNumber;
  }

  public JobList jobSliceCount(Integer jobSliceCount) {
    this.jobSliceCount = jobSliceCount;
    return this;
  }

   /**
   * If ran as part of sliced jobs, the total number of slices. If 1, job is not part of a sliced job.
   * minimum: 0
   * maximum: 2147483647
   * @return jobSliceCount
  **/
  @Schema(description = "If ran as part of sliced jobs, the total number of slices. If 1, job is not part of a sliced job.")
  public Integer getJobSliceCount() {
    return jobSliceCount;
  }

  public void setJobSliceCount(Integer jobSliceCount) {
    this.jobSliceCount = jobSliceCount;
  }

  public JobList webhookService(WebhookServiceEnum webhookService) {
    this.webhookService = webhookService;
    return this;
  }

   /**
   * Service that webhook requests will be accepted from
   * @return webhookService
  **/
  @Schema(description = "Service that webhook requests will be accepted from")
  public WebhookServiceEnum getWebhookService() {
    return webhookService;
  }

  public void setWebhookService(WebhookServiceEnum webhookService) {
    this.webhookService = webhookService;
  }

  public JobList webhookCredential(Integer webhookCredential) {
    this.webhookCredential = webhookCredential;
    return this;
  }

   /**
   * Personal Access Token for posting back the status to the service API
   * @return webhookCredential
  **/
  @Schema(description = "Personal Access Token for posting back the status to the service API")
  public Integer getWebhookCredential() {
    return webhookCredential;
  }

  public void setWebhookCredential(Integer webhookCredential) {
    this.webhookCredential = webhookCredential;
  }

  public JobList webhookGuid(String webhookGuid) {
    this.webhookGuid = webhookGuid;
    return this;
  }

   /**
   * Unique identifier of the event that triggered this webhook
   * @return webhookGuid
  **/
  @Schema(description = "Unique identifier of the event that triggered this webhook")
  public String getWebhookGuid() {
    return webhookGuid;
  }

  public void setWebhookGuid(String webhookGuid) {
    this.webhookGuid = webhookGuid;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JobList jobList = (JobList) o;
    return Objects.equals(this.id, jobList.id) &&
        Objects.equals(this.type, jobList.type) &&
        Objects.equals(this.url, jobList.url) &&
        Objects.equals(this.related, jobList.related) &&
        Objects.equals(this.summaryFields, jobList.summaryFields) &&
        Objects.equals(this.created, jobList.created) &&
        Objects.equals(this.modified, jobList.modified) &&
        Objects.equals(this.name, jobList.name) &&
        Objects.equals(this.description, jobList.description) &&
        Objects.equals(this.unifiedJobTemplate, jobList.unifiedJobTemplate) &&
        Objects.equals(this.launchType, jobList.launchType) &&
        Objects.equals(this.status, jobList.status) &&
        Objects.equals(this.executionEnvironment, jobList.executionEnvironment) &&
        Objects.equals(this.failed, jobList.failed) &&
        Objects.equals(this.started, jobList.started) &&
        Objects.equals(this.finished, jobList.finished) &&
        Objects.equals(this.canceledOn, jobList.canceledOn) &&
        Objects.equals(this.elapsed, jobList.elapsed) &&
        Objects.equals(this.jobExplanation, jobList.jobExplanation) &&
        Objects.equals(this.executionNode, jobList.executionNode) &&
        Objects.equals(this.controllerNode, jobList.controllerNode) &&
        Objects.equals(this.launchedBy, jobList.launchedBy) &&
        Objects.equals(this.workUnitId, jobList.workUnitId) &&
        Objects.equals(this.jobType, jobList.jobType) &&
        Objects.equals(this.inventory, jobList.inventory) &&
        Objects.equals(this.project, jobList.project) &&
        Objects.equals(this.playbook, jobList.playbook) &&
        Objects.equals(this.scmBranch, jobList.scmBranch) &&
        Objects.equals(this.forks, jobList.forks) &&
        Objects.equals(this.limit, jobList.limit) &&
        Objects.equals(this.verbosity, jobList.verbosity) &&
        Objects.equals(this.extraVars, jobList.extraVars) &&
        Objects.equals(this.jobTags, jobList.jobTags) &&
        Objects.equals(this.forceHandlers, jobList.forceHandlers) &&
        Objects.equals(this.skipTags, jobList.skipTags) &&
        Objects.equals(this.startAtTask, jobList.startAtTask) &&
        Objects.equals(this.timeout, jobList.timeout) &&
        Objects.equals(this.useFactCache, jobList.useFactCache) &&
        Objects.equals(this.organization, jobList.organization) &&
        Objects.equals(this.jobTemplate, jobList.jobTemplate) &&
        Objects.equals(this.passwordsNeededToStart, jobList.passwordsNeededToStart) &&
        Objects.equals(this.allowSimultaneous, jobList.allowSimultaneous) &&
        Objects.equals(this.artifacts, jobList.artifacts) &&
        Objects.equals(this.scmRevision, jobList.scmRevision) &&
        Objects.equals(this.instanceGroup, jobList.instanceGroup) &&
        Objects.equals(this.diffMode, jobList.diffMode) &&
        Objects.equals(this.jobSliceNumber, jobList.jobSliceNumber) &&
        Objects.equals(this.jobSliceCount, jobList.jobSliceCount) &&
        Objects.equals(this.webhookService, jobList.webhookService) &&
        Objects.equals(this.webhookCredential, jobList.webhookCredential) &&
        Objects.equals(this.webhookGuid, jobList.webhookGuid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, url, related, summaryFields, created, modified, name, description, unifiedJobTemplate, launchType, status, executionEnvironment, failed, started, finished, canceledOn, elapsed, jobExplanation, executionNode, controllerNode, launchedBy, workUnitId, jobType, inventory, project, playbook, scmBranch, forks, limit, verbosity, extraVars, jobTags, forceHandlers, skipTags, startAtTask, timeout, useFactCache, organization, jobTemplate, passwordsNeededToStart, allowSimultaneous, artifacts, scmRevision, instanceGroup, diffMode, jobSliceNumber, jobSliceCount, webhookService, webhookCredential, webhookGuid);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JobList {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    related: ").append(toIndentedString(related)).append("\n");
    sb.append("    summaryFields: ").append(toIndentedString(summaryFields)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    unifiedJobTemplate: ").append(toIndentedString(unifiedJobTemplate)).append("\n");
    sb.append("    launchType: ").append(toIndentedString(launchType)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    executionEnvironment: ").append(toIndentedString(executionEnvironment)).append("\n");
    sb.append("    failed: ").append(toIndentedString(failed)).append("\n");
    sb.append("    started: ").append(toIndentedString(started)).append("\n");
    sb.append("    finished: ").append(toIndentedString(finished)).append("\n");
    sb.append("    canceledOn: ").append(toIndentedString(canceledOn)).append("\n");
    sb.append("    elapsed: ").append(toIndentedString(elapsed)).append("\n");
    sb.append("    jobExplanation: ").append(toIndentedString(jobExplanation)).append("\n");
    sb.append("    executionNode: ").append(toIndentedString(executionNode)).append("\n");
    sb.append("    controllerNode: ").append(toIndentedString(controllerNode)).append("\n");
    sb.append("    launchedBy: ").append(toIndentedString(launchedBy)).append("\n");
    sb.append("    workUnitId: ").append(toIndentedString(workUnitId)).append("\n");
    sb.append("    jobType: ").append(toIndentedString(jobType)).append("\n");
    sb.append("    inventory: ").append(toIndentedString(inventory)).append("\n");
    sb.append("    project: ").append(toIndentedString(project)).append("\n");
    sb.append("    playbook: ").append(toIndentedString(playbook)).append("\n");
    sb.append("    scmBranch: ").append(toIndentedString(scmBranch)).append("\n");
    sb.append("    forks: ").append(toIndentedString(forks)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    verbosity: ").append(toIndentedString(verbosity)).append("\n");
    sb.append("    extraVars: ").append(toIndentedString(extraVars)).append("\n");
    sb.append("    jobTags: ").append(toIndentedString(jobTags)).append("\n");
    sb.append("    forceHandlers: ").append(toIndentedString(forceHandlers)).append("\n");
    sb.append("    skipTags: ").append(toIndentedString(skipTags)).append("\n");
    sb.append("    startAtTask: ").append(toIndentedString(startAtTask)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    useFactCache: ").append(toIndentedString(useFactCache)).append("\n");
    sb.append("    organization: ").append(toIndentedString(organization)).append("\n");
    sb.append("    jobTemplate: ").append(toIndentedString(jobTemplate)).append("\n");
    sb.append("    passwordsNeededToStart: ").append(toIndentedString(passwordsNeededToStart)).append("\n");
    sb.append("    allowSimultaneous: ").append(toIndentedString(allowSimultaneous)).append("\n");
    sb.append("    artifacts: ").append(toIndentedString(artifacts)).append("\n");
    sb.append("    scmRevision: ").append(toIndentedString(scmRevision)).append("\n");
    sb.append("    instanceGroup: ").append(toIndentedString(instanceGroup)).append("\n");
    sb.append("    diffMode: ").append(toIndentedString(diffMode)).append("\n");
    sb.append("    jobSliceNumber: ").append(toIndentedString(jobSliceNumber)).append("\n");
    sb.append("    jobSliceCount: ").append(toIndentedString(jobSliceCount)).append("\n");
    sb.append("    webhookService: ").append(toIndentedString(webhookService)).append("\n");
    sb.append("    webhookCredential: ").append(toIndentedString(webhookCredential)).append("\n");
    sb.append("    webhookGuid: ").append(toIndentedString(webhookGuid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
